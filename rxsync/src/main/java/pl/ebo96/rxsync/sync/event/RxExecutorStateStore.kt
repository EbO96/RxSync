package pl.ebo96.rxsync.sync.event

import io.reactivex.functions.Consumer
import org.reactivestreams.Subscription
import pl.ebo96.rxsync.sync.executor.RxExecutorInfo
import pl.ebo96.rxsync.sync.method.MethodResult
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger

/**
 * Contains information about progress. Generates unique id's for methods and modules.
 * Prepares information about all modules and single module progress.
 *
 * @param rxProgressListener expose progress for user.
 * @param rxExecutorInfo contain information about methods count etc.
 */
class RxExecutorStateStore(private val rxProgressListener: RxProgressListener?, private val rxExecutorInfo: RxExecutorInfo) {

    /**
     * Done methods ids.
     * @see generateMethodId
     */
    private val doneMethods = ConcurrentHashMap<Int, Int>()

    /**
     * Contains progress per module.
     * 'Key' is module id generated by [generateModuleId].
     * [ConcurrentHashMap] 'key' is module done methods and 'value' is module total methods.
     */
    private val perModuleProgress = ConcurrentHashMap<Int, ConcurrentHashMap<Int, Int>>()

    /**
     * Integer which actual value is last created method id.
     *
     * @see generateMethodId
     */
    private val methodsIdStore: AtomicInteger = AtomicInteger()

    /**
     * Integer which actual value is last created module id.
     *
     * @see generateModuleId
     */
    private val moduleIdStore: AtomicInteger = AtomicInteger()

    /**
     * Generate unique module id.
     */
    internal fun generateModuleId(): Int {
        return moduleIdStore.getAndIncrement()
    }

    /**
     * Generate unique method id.
     */
    internal fun generateMethodId(): Int {
        return methodsIdStore.incrementAndGet()
    }

    /**
     * Sum of all done methods.
     */
    private fun getDoneMethodsCount(): Int {
        return doneMethods.size
    }

    /**
     * Sum of all methods.
     */
    private fun getAllMethodsCount(): Int {
        return rxExecutorInfo.getMethodsCount()
    }

    /**
     * Get progress for module.
     *
     * @param id module id generated by [generateModuleId].
     * @return [RxProgress] for module.
     */
    internal fun getModuleProgress(id: Int): RxProgress {
        val moduleProgress = perModuleProgress[id]
        return RxProgress(
                done = moduleProgress?.keys?.size ?: 0,
                total = moduleProgress?.values?.firstOrNull() ?: 0
        )
    }

    /**
     * Get progress which contains all done methods count and total methods count.
     *
     * @return [RxProgress] for while process.
     */
    internal fun getSummary(): RxProgress {
        return RxProgress(
                done = getDoneMethodsCount(),
                total = getAllMethodsCount()
        )
    }

    /**
     * Invoked every time when method ends.
     *
     * Increments done methods count and per module methods count.
     * @see doneMethods
     * @see perModuleProgress
     *
     * @return [Consumer] used by RxJava2 'subscribe' method.
     */
    internal fun <T : Any> updateProgressAndExposeResult(rxResultListener: RxResultListener<T>?): Consumer<MethodResult<out T>> = Consumer { methodResult ->
        //Save info about done methods
        val methodId = methodResult.methodInfo.getMethodId()
        doneMethods[methodId] = methodId

        //Save info about module done methods
        val moduleDoneMethods: ConcurrentHashMap<Int, Int> = perModuleProgress[methodResult.module.getModuleId()]
                ?: ConcurrentHashMap()

        moduleDoneMethods[methodId] = methodResult.module.getMethodsCount()
        perModuleProgress[methodResult.module.getModuleId()] = moduleDoneMethods

        //Expose method result on UI and progress for user
        val rxProgress = getSummary()
        rxResultListener?.onNextUiResult(methodResult)
        rxProgressListener?.onProgress(rxProgress)

        val moduleProgress = getModuleProgress(methodResult.module.getModuleId())

        rxProgressListener?.onModuleProgress(methodResult.module, moduleProgress)
    }

    /**
     * Reset all counters
     */
    internal fun reset(): Consumer<in Subscription> = Consumer {
        doneMethods.clear()
        perModuleProgress.clear()
        rxExecutorInfo.removeMethods()
    }
}